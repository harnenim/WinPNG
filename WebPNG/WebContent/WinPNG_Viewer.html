<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>WinPNG 뷰어</title>
<script title="java.awt.image.BufferedImage">
var BufferedImage = function(w, h) {
	if (typeof w == "object") {
		this.canvas = w;
		this.width  = this.canvas.width ;
		this.height = this.canvas.height;
	} else {
		this.canvas = document.createElement("canvas");
		this.canvas.style.width  = (this.canvas.width  = this.width  = w) + "px";
		this.canvas.style.height = (this.canvas.height = this.height = h) + "px";
	}
	this.context = this.canvas.getContext("2d");
	this.data = this.context.getImageData(0, 0, this.canvas.width, this.canvas.height);
}
BufferedImage.prototype.getWidth  = function() { return this.width ; };
BufferedImage.prototype.getHeight = function() { return this.height; };
BufferedImage.prototype.getRGB = function(x, y) {
	var index = 4 * ((this.width * y) + x);
	return (this.data.data[index  ] << 16)
	     | (this.data.data[index+1] <<  8)
	     | (this.data.data[index+2]      );
}
BufferedImage.prototype.setRGB = function(x, y, rgb) {
	var index = 4 * ((this.width * y) + x);
	this.data.data[index  ] = (rgb >> 16) & 0xFF;
	this.data.data[index+1] = (rgb >>  8) & 0xFF;
	this.data.data[index+2] = (rgb      ) & 0xFF;
	this.data.data[index+3] = 0xFF;
}
BufferedImage.prototype.getRGBs = function(offsetX, offsetY, width, height) {
	var result = [];
	for (var x = 0; x < width; x++) {
		for (var y = 0; y < height; y++) {
			result[(width * y) + x] = this.getRGB(offsetX + x, offsetY + y);
		}
	}
	return result;
}
BufferedImage.prototype.update = function() {
	this.context.putImageData(this.data, 0, 0);
	return this;
}
</script>
<script title="moe.ohli.pngb.Container">
function pad0(str, len) {
	return pad(str, len, '0');
}
function toHex(value, len) {
	return pad(value.toString(16), len, '0');
}
function pad(str, len, pad) {
	while (str.length < len) {
		str = pad + str;
	}
	return str;
}

function pathLengthFromRGB(rgb) {
	if ((rgb&0xFFFF00) == 0) {
		return rgb & 0xFF; // 레거시 지원
	}
	return ((rgb&0x070000) >> 11) | ((rgb&0x000300) >> 5) | (rgb&0x000007);
}

function bytesToRGBs(bytes) {
	var result = new Array(Math.floor((bytes.length + 2) / 3));
	for (var i = 0; i < result.length; i++) {
		result[i] = 0;
	}
	for (var i = 0; i < bytes.length; i++) {
		result[Math.floor(i / 3)] |= ((bytes[i] & 0xFF) << ((2 - (i % 3)) * 8)) & 0xFFFFFF;
	}
	return result;
}
function getShift(key) {
	return fibonacci(key.length);
}
function getXors(key) {
	var bytes = new TextEncoder().encode(key);
	for (var i = 0; i < bytes.length; i++) {
		bytes[i] =                      // 75361420
				( ((bytes[i] << (7-0)) & 0b10000000)
				| ((bytes[i] << (5-1)) & 0b01000000)
				| ((bytes[i] << (3-2)) & 0b00100000)
				| ((bytes[i] << (6-3)) & 0b00010000)
				| ((bytes[i] << (1-4)) & 0b00001000)
				| ((bytes[i] << (4-5)) & 0b00000100)
				| ((bytes[i] << (2-6)) & 0b00000010)
				| ((bytes[i] << (0-7)) & 0b00000001)
				);
	}
	return bytesToRGBs(bytes);
}
function fibonacci(no) {
	return subFibonacci(0, 1, no - 1);
}
function subFibonacci(before, current, left) {
	if (left < 0) {
		return before;
	} else if (left == 0) {
		return current;
	} else {
		return subFibonacci(current, before + current, left - 1);
	}
}

var Container = function(rgbs, shift=0, xors=[]) {
	console.debug("pathLength  : " + toHex(rgbs[ shift    % rgbs.length], 8));
	console.debug("binaryLength: " + toHex(rgbs[(shift+1) % rgbs.length], 8));
	// xor 연산 수행
	if (xors.length > 0) {
		console.debug("xors0       : " + toHex(xors[ shift    % xors.length], 8));
		console.debug("xors1       : " + toHex(xors[(shift+1) % xors.length], 8));
		for (var i = 0; i < rgbs.length; i++) {
			rgbs[i] ^= xors[i % xors.length];
		}
	}
	var pathLength = pathLengthFromRGB(rgbs[ shift    % rgbs.length]);
	var binaryLength = 0xFFFFFF &      rgbs[(shift+1) % rgbs.length];
	console.debug("pathLength  : " + pathLength);
	console.debug("binaryLength: " + binaryLength);
	
	this.setDataFromRGBs(rgbs, shift, pathLength, binaryLength);
	
};
Container.prototype.setDataFromRGBs = function(rgbs, shift, pathLength, binaryLength) {
	if (binaryLength > 20971520) {
		throw new Exception("이미지 해석 오류");
	}
	
	var offset = shift + 2;
	
	// RGB
	console.debug("RGB");
	var bytes = new Uint8Array(pathLength);
	for (var i = 0; i < pathLength; i++) {
		bytes[i] = ((rgbs[(offset + Math.floor(i/3)) % rgbs.length] >> (8 * (2-(i%3)))) & 0xFF);
	}
	console.debug("pathBytes: " + bytes.length);
	this.path = new TextDecoder("UTF-8").decode(bytes);
	offset += Math.floor((pathLength + 2) / 3);
	
	this.binary = new Uint8Array(binaryLength);
	for (var i = 0; i < binaryLength; i++) {
		this.binary[i] = ((rgbs[(offset + Math.floor(i/3)) % rgbs.length] >> (8 * (2-(i%3)))) & 0xFF);
	}
}
/**
 * 비트맵 이미지를 컨테이너 목록으로 변환
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return 컨테이너 목록
 * @throws Exception
 */
Container.fromBitmap = async function(bmp, shift=0, xors=[]) {
	console.info("\nContainer.fromBitmap");
	var containers = [];
	
	var offsetY = 0;
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	shift = shift % width;
	console.info("input size: " + width + " x " + height);
	
	while (offsetY < height) {
		console.debug("shift: " + shift);
		console.debug("xors.length: " + xors.length);
		var pathLength   = 0xFFFFFF & bmp.getRGB( shift    % width, offsetY);
		var binaryLength = 0xFFFFFF & bmp.getRGB((shift+1) % width, offsetY);
		console.debug("pathLength  : " + toHex(pathLength  , 8));
		console.debug("binaryLength: " + toHex(binaryLength, 8));
		if (xors.length > 0) {
			console.debug("xors0       : " + toHex(xors[ shift    % xors.length], 8));
			console.debug("xors1       : " + toHex(xors[(shift+1) % xors.length], 8));
			pathLength   = (pathLength   ^ xors[ shift    % xors.length]) & 0xFFFFFF;
			binaryLength = (binaryLength ^ xors[(shift+1) % xors.length]) & 0xFFFFFF;
		}
		pathLength = pathLengthFromRGB(pathLength);
		var pixelCount = 2 + Math.ceil(pathLength / 3) + Math.ceil(binaryLength / 3);
		var contHeight = Math.floor((pixelCount + width - 1) / width);
		console.debug("");
		console.debug("pathLength  : " + pathLength);
		console.debug("binaryLength: " + binaryLength);
		console.debug("pixelCount: " + pixelCount);
		console.debug("contHeight: " + contHeight);
		if (pathLength > 255) { // pathLengthFromRGB 적용하면서 이렇게 나올 일이 없음...
			console.warn("잘못된 경로 길이: " + pathLength);
			break;
		}
		if (offsetY + contHeight > height) {
			console.warn("잘못된 데이터 크기: " + offsetY + contHeight > height);
			break;
		}
		
		var rgbs = bmp.getRGBs(0, offsetY, width, contHeight);
		var cont = new Container(rgbs, shift, xors);
		console.debug("path: " + cont.path);
		
		if (pathLength == 0) {
			// 경로가 없음: 이중 변환 or 정크 영역
			try {
				// 이중 변환으로 가정하고 해석 시도
				var subImg = new Image();
				subImg.src = URL.createObjectURL(new Blob([cont.binary], { type: "image/png" }));
				await subImg.decode();

				var w = subImg.naturalWidth;
				var h = subImg.naturalHeight;

				var canvas = document.createElement("canvas");
				canvas.style.width  = (canvas.width  = w) + "px";
				canvas.style.height = (canvas.height = h) + "px";
				canvas.getContext("2d").drawImage(subImg, 0, 0);

				containers = containers.concat(await Container.fromBitmap(new BufferedImage(canvas)));
				
			} catch (e) {
				console.info("JUNK DATA");
			}
		} else {
			// 잘못된 경로: 해석 실패 - 이것만으론 불충분할 수도...
			if (cont.path.indexOf("*") >= 0
			 || cont.path.indexOf("?") >= 0
			 || cont.path.indexOf('"') >= 0
			 || cont.path.indexOf("<") >= 0
			 || cont.path.indexOf(">") >= 0
			 || cont.path.indexOf("|") >= 0
			 || cont.path.indexOf("\\") >= 0 // 모두 /으로 치환돼있어야 함
			 || cont.path.indexOf("�") >= 0
					) {
				//throw new Exception("잘못된 경로");
				console.warn("잘못된 경로: " + cont.path);
				break;
			}
			// 경로가 있음: 일반 파일
			containers.push(cont);
		}
		
		offsetY += contHeight;
	}
	
	return containers;
}
</script>
<script title="moe.ohli.pngb.Container.WithTarget">
var TYPE_114v1 = 1;
var TYPE_149   = 2;
var TYPE_238   = 3;
var TYPE_429   = 4;
var TYPE_114v2 = 5;
var TYPE_114v3 = 6;
var TYPE_124   = 7;
var TYPE_114 = TYPE_114v3;

var CHECKSUM_SAMPLE_COUNT = 10; // 패리티 검증 체크섬 샘플 개수
var CAN_PROTOTYPE = 1;
var CAN_114v1 = 1 << TYPE_114v1;
var CAN_149   = 1 << TYPE_149;
var CAN_238   = 1 << TYPE_238;
var CAN_429   = 1 << TYPE_429;
var CAN_114v2 = 1 << TYPE_114v2;
var CAN_114v3 = 1 << TYPE_114v3;
var CAN_124   = 1 << TYPE_124;

var WithTarget = function(targetImage, containers, type) {
	this.targetImage = targetImage;
	this.containers = containers;
	this.type = type;
};

/**
 * 패리티 검증으로 해석 가능한 알고리즘 확인
 * @param bmp
 * @return 가능한 알고리즘
 */
WithTarget.possibility = function(bmp) {
	var result = 0;
	if (WithTarget.canPrototype(bmp)) { result |= CAN_PROTOTYPE; }
	if (WithTarget.can114v3    (bmp)) { result |= CAN_114v3;     }
	if (WithTarget.can114v2    (bmp)) { result |= CAN_114v2;     }
	if (WithTarget.can114      (bmp)) { result |= CAN_114v1;     }
	if (WithTarget.can149      (bmp)) { result |= CAN_149;       }
	if (WithTarget.can238      (bmp)) { result |= CAN_238;       }
	if (WithTarget.can429      (bmp)) { result |= CAN_429;       }
	if (WithTarget.can124      (bmp)) { result |= CAN_124;       }
	return result;
}

// b = (a+d)/₂
function getB(a, d) {
	//     (                a           +  d                        ) / 2
	return ( ((            (a&0xFF0000) + (d&0xFF0000)) & 0x1FE0000)
	       | ((            (a&0x00FF00) + (d&0x00FF00)) & 0x001FE00)
	       | ((            (a&0x0000FF) + (d&0x0000FF)) & 0x00001FE)) >> 1;
}
// c = (1+a-d)/₂
function getC(a, d) {
	//     (     1       +  a           -  d                        ) / 2
	return ( ((0x1000000 + (a&0xFF0000) - (d&0xFF0000)) & 0x1FE0000)
	       | ((0x0010000 + (a&0x00FF00) - (d&0x00FF00)) & 0x001FE00)
	       | ((0x0000100 + (a&0x0000FF) - (d&0x0000FF)) & 0x00001FE)) >> 1;
}
// {½ + b - c} = {½ + (a+d)/₂ - (1+a-d)/₂} = {(1+a+d-1-a+d)/₂} = d
function getD(b, c) {
	//      1/2      +  b           -  c
	return (0x800000 + (b&0xFF0000) - (c&0xFF0000))
	     | (0x008000 + (b&0x00FF00) - (c&0x00FF00))
	     | (0x000080 + (b&0x0000FF) - (c&0x0000FF));
	
}
// {½ + a - b - c} = {½ + 2a/₂ - (a+d)/₂ - (1+a-d)/₂} = {(1+2a-a-d-1-a+d)/₂} = 0
function isValid(a, b, c, d) {
	//              1/2      +  a           -  b           -  c
	var checksum = (0x800000 + (a&0xFF0000) - (b&0xFF0000) - (c&0xFF0000))
	             + (0x008000 + (a&0x00FF00) - (b&0x00FF00) - (c&0x00FF00))
	             + (0x000080 + (a&0x0000FF) - (b&0x0000FF) - (c&0x0000FF));

	console.debug("{ " + a
	           + " / " + b
	           + " / " + c
	           + " / " + d
	           + " } -> checksum: " + checksum);
	console.debug("{ " + toHex(a, 6)
	           + " / " + toHex(b, 6)
	           + " / " + toHex(c, 6)
	           + " / " + toHex(d, 6)
	           + " } -> checksum: " + toHex(checksum, 6));
	
	var compare = (((a&0x010101)+(d&0x010101))&0x010101); // 정수연산 한계로 a+d가 홀수일 땐 1이 나옴
	
	if (checksum == compare) {
		return true;
	} else {
		console.debug("is not " + toHex(compare, 6));
		return false;
	}
}

function getBp2x(ax, dx, bx) {
	return (ax < 0x80 == dx < 0x80) ? 0x80 : ((0x280 + ax - 2*dx) / 8 * 2 + 1);
}
function getCp2x(ax, dx, cx) {
	return (ax < 0x80 != dx < 0x80) ? 0x80 : ((0x80 + ax + 2*dx) / 8 * 2);
}
function getAp2x(ax, bx, cx, dx) {
	return 0x180 - getBp2x(ax, dx, bx) - getCp2x(ax, dx, cx);
}
function getBv2(a, d, b) {
	return ( ((b&0xFF0000) + (getBp2x((a >> 16) & 0xFF, (d >> 16) & 0xFF, (b >> 16) & 0xFF) << 16) - 0x800000)
	       | ((b&0x00FF00) + (getBp2x((a >>  8) & 0xFF, (d >>  8) & 0xFF, (b >>  8) & 0xFF) <<  8) - 0x008000)
	       | ((b&0x0000FF) + (getBp2x((a >>  0) & 0xFF, (d >>  0) & 0xFF, (b >>  0) & 0xFF) <<  0) - 0x000080) );
}
function getCv2(a, d, c) {
	return ( ((c&0xFF0000) + (getCp2x((a >> 16) & 0xFF, (d >> 16) & 0xFF, (c >> 16) & 0xFF) << 16) - 0x800000)
	       | ((c&0x00FF00) + (getCp2x((a >>  8) & 0xFF, (d >>  8) & 0xFF, (c >>  8) & 0xFF) <<  8) - 0x008000)
	       | ((c&0x0000FF) + (getCp2x((a >>  0) & 0xFF, (d >>  0) & 0xFF, (c >>  0) & 0xFF) <<  0) - 0x000080) );
}
function getAv2(a, b, c, d) {
	return ( ((a&0xFF0000) + (getAp2x((a >> 16) & 0xFF, (b >> 16) & 0xFF, (c >> 16) & 0xFF, (d >> 16) & 0xFF) << 16) - 0x800000)
	       | ((a&0x00FF00) + (getAp2x((a >>  8) & 0xFF, (b >>  8) & 0xFF, (c >>  8) & 0xFF, (d >>  8) & 0xFF) <<  8) - 0x008000)
	       | ((a&0x0000FF) + (getAp2x((a >>  0) & 0xFF, (b >>  0) & 0xFF, (c >>  0) & 0xFF, (d >>  0) & 0xFF) <<  0) - 0x000080) );
}
function getAp(a, an) {
	return 0x808080 + an - a;
}
function b2toB(bn, ap) {
	return 0x808080 + bn
			- (((ap&0x010000) == 0x000000) ? 0x800000 : (0x1000000 - (ap&0xFF0000)))
			- (((ap&0x000100) == 0x000000) ? 0x008000 : (0x0010000 - (ap&0x00FF00)))
			- (((ap&0x000001) == 0x000000) ? 0x000080 : (0x0000100 - (ap&0x0000FF)));
}
function c2toC(cn, ap) {
	return 0x808080 + cn
			- (((ap&0x010000) == 0x010000) ? 0x800000 : (0x1000000 - (ap&0xFF0000)))
			- (((ap&0x000100) == 0x000100) ? 0x008000 : (0x0010000 - (ap&0x00FF00)))
			- (((ap&0x000001) == 0x000001) ? 0x000080 : (0x0000100 - (ap&0x0000FF)));
}

// for 1:1:4 v3
function getBp3(a, d) {
	return ( ((((a&0x800000) ^ (d&0x800000)) == 0x000000) ? (0xC00000 - (((0x0800000 + (a&0xFF0000) + 2*(d&0xFF0000)) >> 3) & 0xFE0000)) : (((0x2800000 + (a&0xFF0000) - 2*(d&0xFF0000)) >> 2) & 0xFC0000) | 0x010000)
	       | ((((a&0x008000) ^ (d&0x008000)) == 0x000000) ? (0x00C000 - (((0x0008000 + (a&0x00FF00) + 2*(d&0x00FF00)) >> 3) & 0x00FE00)) : (((0x0028000 + (a&0x00FF00) - 2*(d&0x00FF00)) >> 2) & 0x00FC00) | 0x000100)
	       | ((((a&0x000080) ^ (d&0x000080)) == 0x000000) ? (0x0000C0 - (((0x0000080 + (a&0x0000FF) + 2*(d&0x0000FF)) >> 3) & 0x0000FE)) : (((0x0000280 + (a&0x0000FF) - 2*(d&0x0000FF)) >> 2) & 0x0000FC) | 0x000001) );
}
function getCp3(a, d) {
	return ( ((((a&0x800000) ^ (d&0x800000)) == 0x800000) ? (0xC00000 - (((0x2800000 + (a&0xFF0000) - 2*(d&0xFF0000)) >> 3) & 0xFE0000)) : (((0x0800000 + (a&0xFF0000) + 2*(d&0xFF0000)) >> 2) & 0xFC0000))
	       | ((((a&0x008000) ^ (d&0x008000)) == 0x008000) ? (0x00C000 - (((0x0028000 + (a&0x00FF00) - 2*(d&0x00FF00)) >> 3) & 0x00FE00)) : (((0x0008000 + (a&0x00FF00) + 2*(d&0x00FF00)) >> 2) & 0x00FC00))
	       | ((((a&0x000080) ^ (d&0x000080)) == 0x000080) ? (0x0000C0 - (((0x0000280 + (a&0x0000FF) - 2*(d&0x0000FF)) >> 3) & 0x0000FE)) : (((0x0000080 + (a&0x0000FF) + 2*(d&0x0000FF)) >> 2) & 0x0000FC)) );
}
function getBv3(b, bp) { return b + bp - 0x808080; }
function getCv3(c, cp) { return c + cp - 0x808080; }
function getAv3(a, bp, cp) { return a + 0x1010100 - bp - cp; }
function b3toB(bn, ap) {
	return 0x808080 + bn
			- (((ap&0x010000) == 0) ? (ap&0xFF0000) : (0x17F0000 - ((ap&0xFF0000)<<1)))
			- (((ap&0x000100) == 0) ? (ap&0x00FF00) : (0x0017F00 - ((ap&0x00FF00)<<1)))
			- (((ap&0x000001) == 0) ? (ap&0x0000FF) : (0x000017F - ((ap&0x0000FF)<<1)));
}
function c3toC(cn, ap) {
	return 0x808080 + cn
			- (((ap&0x010000) == 0) ? (0x1800000 - ((ap&0xFF0000)<<1)) : ((ap&0xFF0000) + 0x010000))
			- (((ap&0x000100) == 0) ? (0x0018000 - ((ap&0x00FF00)<<1)) : ((ap&0x00FF00) + 0x000100))
			- (((ap&0x000001) == 0) ? (0x0000180 - ((ap&0x0000FF)<<1)) : ((ap&0x0000FF) + 0x000001));
}

// for 1:2:4
function getA124(a, ad1, ad2, a1) {
	return (getA124x(((a>>16)&0xFF) * 3, (((ad1>>16)&0xFF) + ((ad2>>16)&0xFF) + ((a1>>16)&0xFF)), (a1>>16)&0xFF) << 16)
	     | (getA124x(((a>> 8)&0xFF) * 3, (((ad1>> 8)&0xFF) + ((ad2>> 8)&0xFF) + ((a1>> 8)&0xFF)), (a1>> 8)&0xFF) <<  8)
	     | (getA124x(((a>> 0)&0xFF) * 3, (((ad1>> 0)&0xFF) + ((ad2>> 0)&0xFF) + ((a1>> 0)&0xFF)), (a1>> 0)&0xFF) <<  0);
}
function getA124x(ax, nx, a1x) {
	return (Math.max(0, Math.min(0xF0, a1x + ax - nx)) & 0xF0) | (a1x & 0x0F);
}

function padRGB(value) {
	var str = pad0(Integer.toBinaryString(value), 24);
	return str.substring(0, 8) + " " + str.substring(8, 16) + " " + str.substring(16, 24);
}

/**
 * 1:1:4 레거시 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.canPrototype = function(bmp) {
	console.info("\nis it prototype?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 1:1:4 결합 이미지일 경우 크기는 짝수여야 함
	if (width % 2 > 0 || height % 2 > 0) {
		return false;
	};
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 2);
		var y = Math.floor(Math.random() * height / 2);
		
		// (2x,2y)와 (2x+1,2y+1)은 둘 다 출력물 이미지의 원본 픽셀로 같은 값이어야 함
		if ((bmp.getRGB(2*x, 2*y  ) & 0xFFFFFF) != (bmp.getRGB(2*x+1, 2*y+1) & 0xFFFFFF)) {
			checkFailed = true;
			break;
		}
		
		// (2x+1,2y)와 (2x,2y+1)은 합쳐서 0xFFFFFF가 나와야 함
		if ((bmp.getRGB(2*x, 2*y+1) & 0xFFFFFF)  + (bmp.getRGB(2*x+1, 2*y  ) & 0xFFFFFF) != 0xFFFFFF) {
			checkFailed = true;
			break;
		}
	}
	if (checkFailed) {
		console.info("체크섬 오류 - 레거시 WithTarget 1:1:4 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - 레거시 WithTarget 1:1:4 형식 가능");
	return true;
}
/**
 * 1:1:4 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can114 = function(bmp) {
	console.info("\nis it 1:1:4?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 1:1:4 결합 이미지일 경우 크기는 짝수여야 함
	if (width % 2 > 0 || height % 2 > 0) {
		return false;
	}
	
	var a, b, c, d;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 2);
		var y = Math.floor(Math.random() * height / 2);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + ")");
		
		// (2x,2y)와 (2x+1,2y+1)은 둘 다 출력물 이미지의 원본 픽셀로 같은 값이어야 함
		a = bmp.getRGB(2*x  , 2*y  );
		d = bmp.getRGB(2*x+1, 2*y+1);
		if (a != d) {
			console.info("a != d");
			checkFailed = true;
			break;
		}
		
		// 패리티 검증
		b = bmp.getRGB(2*x+1, 2*y  );
		c = bmp.getRGB(2*x  , 2*y+1);
		
		if (!isValid(a, b, c, getD(b, c))) {
			checkFailed = true;
			break;
		}
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 1:1:4 v1 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 1:1:4 v1 형식 가능");
	return true;
}
/**
 * 1:1:4 v2 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can114v2 = function(bmp) {
	console.info("\nis it 1:1:4 v2?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 1:1:4 결합 이미지일 경우 크기는 짝수여야 함
	if (width % 2 > 0 || height % 2 > 0) {
		return false;
	}
	
	var a, bn, cn, an, ap, b, c;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 2);
		var y = Math.floor(Math.random() * height / 2);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + ")");
		
		a  = bmp.getRGB(2*x  , 2*y  );
		bn = bmp.getRGB(2*x+1, 2*y  );
		cn = bmp.getRGB(2*x  , 2*y+1);
		an = bmp.getRGB(2*x+1, 2*y+1);
		ap = getAp(a, an);
		
		b = b2toB(bn, ap);
		c = c2toC(cn, ap);
		
		if (!isValid(a, b, c, getD(b, c))) {
			checkFailed = true;
			break;
		}
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 1:1:4 v2 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 1:1:4 v2 형식 가능");
	return true;
}
/**
 * 1:1:4 v3 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can114v3 = function(bmp) {
	console.info("\nis it 1:1:4 v3?");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 1:1:4 결합 이미지일 경우 크기는 짝수여야 함
	if (width % 2 > 0 || height % 2 > 0) {
		return false;
	}
	
	var a, bn, cn, an, ap, b, c;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 2);
		var y = Math.floor(Math.random() * height / 2);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + ")");
		
		a  = bmp.getRGB(2*x  , 2*y  );
		bn = bmp.getRGB(2*x+1, 2*y  );
		cn = bmp.getRGB(2*x  , 2*y+1);
		an = bmp.getRGB(2*x+1, 2*y+1);
		ap = getAp(a, an);
		b = b3toB(bn, ap);
		c = c3toC(cn, ap);
		
		if (!isValid(a, b, c, getD(b, c))) {
			checkFailed = true;
			break;
		}
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 1:1:4 v3 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 1:1:4 v3 형식 가능");
	return true;
}
/**
 * 1:4:9 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can149 = function(bmp) {
	console.info("\nis it 1:4:9?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 1:4:9 결합 이미지일 경우 크기는 3의 배수여야 함
	if (width % 3 > 0 || height % 3 > 0) {
		return false;
	}
	
	var b1, c1, b2
	  , c4, a , c2
	  , b4, c3, b3;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 3);
		var y = Math.floor(Math.random() * height / 3);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + "):");
		
		a  = bmp.getRGB(3*x+1, 3*y+1);
		b1 = bmp.getRGB(3*x  , 3*y  );
		c1 = bmp.getRGB(3*x+1, 3*y  );
		b2 = bmp.getRGB(3*x+2, 3*y  );
		c2 = bmp.getRGB(3*x+2, 3*y+1);
		b3 = bmp.getRGB(3*x+2, 3*y+2);
		c3 = bmp.getRGB(3*x+1, 3*y+2);
		b4 = bmp.getRGB(3*x  , 3*y+2);
		c4 = bmp.getRGB(3*x  , 3*y+1);
		
		// 패리티 검증
		if (!isValid(a, b1, c1, getD(b1, c1))) { checkFailed = true; break; }
		if (!isValid(a, b2, c2, getD(b2, c2))) { checkFailed = true; break; }
		if (!isValid(a, b3, c3, getD(b3, c3))) { checkFailed = true; break; }
		if (!isValid(a, b4, c4, getD(b4, c4))) { checkFailed = true; break; }
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 1:4:9 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 1:4:9 형식 가능");
	return true;
}
/**
 * 2:3:8 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can238 = function(bmp) {
	console.info("\nis it 2:3:8?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 2:3:8 결합 이미지일 경우 크기는 6x4의 배수여야 함
	if (width % 6 > 0 || height % 4 > 0) {
		return false;
	}
	
	var b1, a1
	  , c1, b2
	  , a2, c2
	  , b3, c3, a3;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 2);
		var y = Math.floor(Math.random() * height / 4);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + "):");
		
		a1 = bmp.getRGB(2*x+1, 4*y  );
		a2 = bmp.getRGB(2*x  , 4*y+2);
		b1 = bmp.getRGB(2*x  , 4*y  );
		c1 = bmp.getRGB(2*x  , 4*y+1);
		b2 = bmp.getRGB(2*x+1, 4*y+1);
		c2 = bmp.getRGB(2*x+1, 4*y+2);
		b3 = bmp.getRGB(2*x  , 4*y+3);
		c3 = bmp.getRGB(2*x+1, 4*y+3);
		a3 = ((((a1&0xFF0000) + (a2&0xFF0000)) >> 1) & 0xFF0000)
		   | ((((a1&0x00FF00) + (a2&0x00FF00)) >> 1) & 0x00FF00)
		   | ((((a1&0x0000FF) + (a2&0x0000FF)) >> 1) & 0x0000FF);
		
		// 패리티 검증
		if (!isValid(a1, b1, c1, getD(b1, c1))) { checkFailed = true; break; }
		if (!isValid(a3, b2, c2, getD(b2, c2))) { checkFailed = true; break; }
		if (!isValid(a2, b3, c3, getD(b3, c3))) { checkFailed = true; break; }
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 2:3:8 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 2:3:8 형식 가능");
	return true;
}
/**
 * 4:2:9 형식 해석이 가능한지 패리티 검증
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can429 = function(bmp) {
	console.info("\nis it 4:2:9?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 4:2:9 결합 이미지일 경우 크기는 3의 배수여야 함
	if (width % 3 > 0 || height % 3 > 0) {
		return false;
	}
	
	var a1, b1, aA
	  , c1,aAB, c2
	  , aB, b2, a2;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 3);
		var y = Math.floor(Math.random() * height / 3);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + "):");
		
		a1 = bmp.getRGB(3*x  , 3*y  );
		aA = bmp.getRGB(3*x+2, 3*y  );
		aB = bmp.getRGB(3*x  , 3*y+2);
		a2 = bmp.getRGB(3*x+2, 3*y+2);
		aAB= bmp.getRGB(3*x+1, 3*y+1) & 0xFFFFFF;
		b1 = bmp.getRGB(3*x+1, 3*y  );
		c1 = bmp.getRGB(3*x  , 3*y+1);
		b2 = bmp.getRGB(3*x+1, 3*y+2);
		c2 = bmp.getRGB(3*x+2, 3*y+1);
		
		// 패리티 검증
		if (!isValid(a1, b1, c1, getD(b1, c1))) { checkFailed = true; break; }
		if (!isValid(a2, b2, c2, getD(b2, c2))) { checkFailed = true; break; }
		if (aAB != ( ((((aA&0xFF0000) + (aB&0xFF0000)) >> 1) & 0xFF0000)
		           | ((((aA&0x00FF00) + (aB&0x00FF00)) >> 1) & 0x00FF00)
		           | ((((aA&0x0000FF) + (aB&0x0000FF)) >> 1) & 0x0000FF) )) {
			console.debug("aAB != (aA+aB)/2");
			checkFailed = true; break;
		}
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 4:2:9 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 4:2:9 형식 가능");
	return true;
}
/**
 * 1:2:4 형식 해석이 가능한지 검증 (패리티 없음)
 * @param bmp
 * @return
 * @throws Exception
 */
WithTarget.can124 = function(bmp) {
	console.info("\nis it 1:2:4?");
	
	var width = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	// 1:2:4 결합 이미지일 경우 크기는 2의 배수여야 함
	if (width % 2 > 0 || height % 2 > 0) {
		return false;
	}
	
	var a, ad1, ad2;
	
	var checkFailed = false;
	
	for (var i = 0; i < CHECKSUM_SAMPLE_COUNT; i++) {
		var x = Math.floor(Math.random() * width  / 2);
		var y = Math.floor(Math.random() * height / 2);
		console.debug("sample(" + pad(x, 4) + ", " + pad(y, 4) + "):");

		a   = bmp.getRGB(2*x  , 2*y  );
		ad1 = bmp.getRGB(2*x+1, 2*y  );
		ad2 = bmp.getRGB(2*x  , 2*y+1);
		
		// 값 범위 검증, 별도 패리티 검사 없음
		if ((a&0xC0C0C0) != (ad1&0xC0C0C0)) { checkFailed = true; break; }
		if ((a&0xC0C0C0) != (ad2&0xC0C0C0)) { checkFailed = true; break; }
	}
	if (checkFailed) {
		console.info("체크섬 오류 - WithTarget 1:2:4 형식 이미지가 아님");
		return false;
	}
	
	console.info("체크섬 통과 - WithTarget 1:2:4 형식 가능");
	return true;
}
/**
 * 1:1:4 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap114 = async function(bmp, shift, xors) {
	console.info("\nWithTarget.fromBitmap 1:1:4");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 2, ySize = height / 2;
	
	var a, b, c;
	
	var targetImage = new BufferedImage(xSize, ySize);
	var dataImage   = new BufferedImage(xSize, ySize);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a = bmp.getRGB(2*x  , 2*y  );
			b = bmp.getRGB(2*x+1, 2*y  );
			c = bmp.getRGB(2*x  , 2*y+1);
			
			targetImage.setRGB(x, y, a);
			dataImage  .setRGB(x, y, getD(b, c));
		}
	}
	
	var containers = await Container.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_114v1);
	}
}
/**
 * 1:1:4 v2 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap114v2 = async function(bmp, shift, xors) {
	console.info("\nWithTarget.fromBitmap 1:1:4 v2");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 2, ySize = height / 2;
	
	var a, an, bn, cn, ap;
	
	var targetImage = new BufferedImage(xSize, ySize);
	var dataImage   = new BufferedImage(xSize, ySize);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a  = bmp.getRGB(2*x  , 2*y  );
			bn = bmp.getRGB(2*x+1, 2*y  );
			cn = bmp.getRGB(2*x  , 2*y+1);
			an = bmp.getRGB(2*x+1, 2*y+1);
			ap = getAp(a, an);
			
			targetImage.setRGB(x, y, a);
			dataImage  .setRGB(x, y, getD(b2toB(bn, ap), c2toC(cn, ap)));
		}
	}
	
	var containers = await Container.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_114v2);
	}
}
/**
 * 1:1:4 v3 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap114v3 = async function(bmp, shift, xors) {
	console.info("\nWithTarget.fromBitmap 1:1:4 v3");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 2, ySize = height / 2;
	
	var a, an, bn, cn, ap;
	
	var targetImage = new BufferedImage(xSize, ySize);
	var dataImage   = new BufferedImage(xSize, ySize);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a  = bmp.getRGB(2*x  , 2*y  );
			bn = bmp.getRGB(2*x+1, 2*y  );
			cn = bmp.getRGB(2*x  , 2*y+1);
			an = bmp.getRGB(2*x+1, 2*y+1);
			ap = getAp(a, an);
			
			targetImage.setRGB(x, y, a);
			dataImage  .setRGB(x, y, getD(b3toB(bn, ap), c3toC(cn, ap)));
		}
	}
	
	var containers = await Container.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_114v3);
	}
}
/**
 * 1:4:9 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap149 = (bmp, shift, xors) => {
	console.info("\nWithTarget.fromBitmap 1:4:9");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 3, ySize = height / 3;
	
	var b1, c1, b2
	  , c4, a , c2
	  , b4, c3, b3;
	
	var targetImage = new BufferedImage(xSize  , ySize  , BufferedImage.TYPE_3BYTE_BGR);
	var dataImage   = new BufferedImage(xSize*2, ySize*2, BufferedImage.TYPE_3BYTE_BGR);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a  = bmp.getRGB(3*x+1, 3*y+1);
			b1 = bmp.getRGB(3*x  , 3*y  );
			c1 = bmp.getRGB(3*x+1, 3*y  );
			b2 = bmp.getRGB(3*x+2, 3*y  );
			c2 = bmp.getRGB(3*x+2, 3*y+1);
			b3 = bmp.getRGB(3*x+2, 3*y+2);
			c3 = bmp.getRGB(3*x+1, 3*y+2);
			b4 = bmp.getRGB(3*x  , 3*y+2);
			c4 = bmp.getRGB(3*x  , 3*y+1);
			
			targetImage.setRGB(x, y, a);
			dataImage.setRGB(2*x  , 2*y  , getD(b1, c1));
			dataImage.setRGB(2*x+1, 2*y  , getD(b2, c2));
			dataImage.setRGB(2*x+1, 2*y+1, getD(b3, c3));
			dataImage.setRGB(2*x  , 2*y+1, getD(b4, c4));
		}
	}
	
	var containers = Container.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_149);
	}
}
/**
 * 2:3:8 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap238 = async function(bmp, shift, xors) {
	console.info("\nWithTarget.fromBitmap 2:3:8");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 2, ySize = height / 4;
	
	var b1, a1
	  , c1, b2
	  , a2, c2
	  , b3, c3;
	
	var targetImage = new BufferedImage(xSize, ySize*2, BufferedImage.TYPE_3BYTE_BGR);
	var dataImage   = new BufferedImage(xSize, ySize*3, BufferedImage.TYPE_3BYTE_BGR);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a1 = bmp.getRGB(2*x+1, 4*y  );
			a2 = bmp.getRGB(2*x  , 4*y+2);
			b1 = bmp.getRGB(2*x  , 4*y  );
			c1 = bmp.getRGB(2*x  , 4*y+1);
			b2 = bmp.getRGB(2*x+1, 4*y+1);
			c2 = bmp.getRGB(2*x+1, 4*y+2);
			b3 = bmp.getRGB(2*x  , 4*y+3);
			c3 = bmp.getRGB(2*x+1, 4*y+3);
			
			targetImage.setRGB(x, 2*y  , a1);
			targetImage.setRGB(x, 2*y+1, a2);
			dataImage.setRGB(x, 3*y  , getD(b1, c1));
			dataImage.setRGB(x, 3*y+1, getD(b2, c2));
			dataImage.setRGB(x, 3*y+2, getD(b3, c3));
		}
	}
	
	var containers = await Container.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_238);
	}
}
/**
 * 4:2:9 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap429 = async function(bmp, shift, xors) {
	console.info("\nWithTarget.fromBitmap 4:2:9");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 3, ySize = height / 3;
	
	var a1, b1, aA
	  , c1,     c2
	  , aB, b2, a2;
	
	var targetImage = new BufferedImage(xSize*2, ySize*2, BufferedImage.TYPE_3BYTE_BGR);
	var dataImage   = new BufferedImage(xSize  , ySize*2, BufferedImage.TYPE_3BYTE_BGR);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a1 = bmp.getRGB(3*x  , 3*y  );
			aA = bmp.getRGB(3*x+2, 3*y  );
			aB = bmp.getRGB(3*x  , 3*y+2);
			a2 = bmp.getRGB(3*x+2, 3*y+2);
			b1 = bmp.getRGB(3*x+1, 3*y  );
			c1 = bmp.getRGB(3*x  , 3*y+1);
			b2 = bmp.getRGB(3*x+1, 3*y+2);
			c2 = bmp.getRGB(3*x+2, 3*y+1);

			targetImage.setRGB(2*x  , 2*y  , a1);
			targetImage.setRGB(2*x+1, 2*y  , aA);
			targetImage.setRGB(2*x  , 2*y+1, aB);
			targetImage.setRGB(2*x+1, 2*y+1, a2);
			dataImage.setRGB(x, 2*y  , getD(b1, c1));
			dataImage.setRGB(x, 2*y+1, getD(b2, c2));
		}
	}
	
	var containers = await Container.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_429);
	}
}
/**
 * 1:2:4 형식 비트맵 이미지를 해석
 * @param bmp
 * @param shift: 출력물 픽셀 밀기
 * @param xors: 출력물 xor 연산 수행
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap124 = async function(bmp, shift, xors) {
	console.info("\nWithTarget.fromBitmap 1:2:4");
	
	var width  = bmp.getWidth();
	var height = bmp.getHeight();
	console.info("input size: " + width + " x " + height);
	
	var xSize = width / 2, ySize = height / 2;
	
	var a, ad1, ad2, a1;
	
	var targetImage = new BufferedImage(xSize, ySize  , BufferedImage.TYPE_3BYTE_BGR);
	var dataImage   = new BufferedImage(xSize, ySize*2, BufferedImage.TYPE_3BYTE_BGR);
	
	for (var y = 0; y < ySize; y++) {
		for (var x = 0; x < xSize; x++) {
			a   = bmp.getRGB(2*x  , 2*y  );
			ad1 = bmp.getRGB(2*x+1, 2*y  );
			ad2 = bmp.getRGB(2*x  , 2*y+1);
			a1  = bmp.getRGB(2*x+1, 2*y+1);
			
			targetImage.setRGB(x  , y  , a);
			dataImage.setRGB(x, 2*y  , ((a1<<4)&0xC0C0C0) | (ad1&0x3F3F3F));
			dataImage.setRGB(x, 2*y+1, ((a1<<6)&0xC0C0C0) | (ad2&0x3F3F3F));
		}
	}
	
	var containers = awaitContainer.fromBitmap(dataImage, shift, xors);
	if (containers.length) {
		return new WithTarget(targetImage, containers, TYPE_124);
	}
}
/**
 * 비트맵 이미지를 주어진 값에 따라 변환 후, 주어진 알고리즘으로 차례로 해석 시도
 *
 * @param bmp
 * @param possibility
 * @param shift
 * @param xors
 * @return
 * @throws Exception
 */
WithTarget.fromBitmap = async function(bmp, possibility, shift=0, xors=[]) {
	console.info("\nWithTarget.fromBitmap");
	
	// 1:1:4 v3 형식으로 시도
	if (((possibility & CAN_114v3) > 0) && (result = await WithTarget.fromBitmap114v3(bmp, shift, xors)) != null) {
		return result;
	}
	// 1:1:4 v2 형식으로 시도
	if (((possibility & CAN_114v2) > 0) && (result = await WithTarget.fromBitmap114v2(bmp, shift, xors)) != null) {
		return result;
	}
	// 1:1:4 v1 형식으로 시도
	if (((possibility & CAN_114v1) > 0) && (result = await WithTarget.fromBitmap114(bmp, shift, xors)) != null) {
		return result;
	}
	// 1:4:9 형식으로 시도
	if (((possibility & CAN_149) > 0) && (result = await WithTarget.fromBitmap149(bmp, shift, xors)) != null) {
		return result;
	}
	// 2:3:8 형식으로 시도
	if (((possibility & CAN_238) > 0) && (result = await WithTarget.fromBitmap238(bmp, shift, xors)) != null) {
		return result;
	}
	// 4:2:9 형식으로 시도
	if (((possibility & CAN_429) > 0) && (result = await WithTarget.fromBitmap429(bmp, shift, xors)) != null) {
		return result;
	}
	// 1:2:4 형식으로 시도
	if (((possibility & CAN_124) > 0) && (result = await WithTarget.fromBitmap124(bmp, shift, xors)) != null) {
		return result;
	}
	
	console.info("Without target 해석 시도");
	var containers = await Container.fromBitmap(bmp, shift, xors);
	if (containers.length) {
		return new WithTarget(null, containers, 0);
	}
	
	return null;
}
</script>
<script>
var inputUrl;
var ivTarget;
var viewFileList;
var preview;

var input = new Image();
input.crossorigin = "anonymous";
var canvas = document.createElement("canvas");
input.onload = async function() {
	try {
		viewFileList.innerHTML = "";
		viewFileList.style.minWidth = "";
		
		var w = this.naturalWidth;
		var h = this.naturalHeight;
		canvas.style.width  = (canvas.width  = w) + "px";
		canvas.style.height = (canvas.height = h) + "px";
		
		var context = canvas.getContext("2d");
		context.drawImage(input, 0, 0);
		
		var bmp = new BufferedImage(canvas);
		var possibility = WithTarget.possibility(bmp);
		var parsed = await WithTarget.fromBitmap(bmp, possibility);

		if (!parsed) {
			// 키값 입력받아서 재시도
			var key = prompt("이미지를 해석할 수 없습니다.\n비밀번호가 있다면 키를 입력하세요.");
			parsed = await WithTarget.fromBitmap(bmp, possibility, getShift(key), getXors(key));
			
			if (!parsed) {
				showTargetImage(bmp);
				setTimeout(() => {
					alert("해석 실패");
				}, 100);
				return;
			}
		}
		
		showTargetImage(parsed.targetImage);
		parsed.containers.sort((cont1, cont2) => {
			return compare(cont1.path, cont2.path);
		});
		for (var i = 0; i < parsed.containers.length; i++) {
			addFile(parsed.containers[i]);
		}
		var minWidth = 0;
		for (var i = 0; i < viewFileList.children.length; i++) {
			var aWidth = 20;
			var a = viewFileList.children[i];
			for (var j = 0; j < a.children.length; j++) {
				aWidth += a.children[j].offsetWidth;
			}
			minWidth = Math.max(minWidth, aWidth);
		}
		viewFileList.style.minWidth = minWidth + "px";
		
	} catch (e) {
		console.debug(e);
		if (e.message.indexOf("cross-origin") > 0) {
			alert("이미지 서버에서 외부 접속을 허용하지 않습니다.\n주소 이외의 방식으로 여시기 바랍니다.");
		}
	}
}
function compare(path1, path2) {
	var index1 = path1.indexOf("/");
	var index2 = path2.indexOf("/");
	if (index1 < 0) {
		if (index2 < 0) {
			// 파일끼리 대소문자 무시하고 비교
			return (path1.toUpperCase() < path2.toUpperCase()) ? -1 : 1;
		} else {
			// Java 버전과 달리 폴더보다 파일이 먼저 보이게 함
			return -1;
		}
	} else {
		if (index2 < 0) {
			// Java 버전과 달리 폴더보다 파일이 먼저 보이게 함
			return 1;
		} else {
			var dir1 = path1.substring(0, index1);
			var dir2 = path2.substring(0, index2);
			if (dir1 == dir2) {
				// 같은 폴더면 하위 내용물 비교
				return compare(path1.substring(index1 + 1), path2.substring(index2 + 1));
			} else {
				// 폴더끼리 대소문자 무시하고 비교
				return (dir1.toUpperCase() < dir2.toUpperCase()) ? -1 : 1;
			}
		}
	}
}
var files = {};
function addFile(cont) {
	var path = cont.path.split("/");
	var filename = path[path.length - 1];
	
	var a = document.createElement("a");
	
	var labelDir = document.createElement("span");
	labelDir.innerText = cont.path.substring(0, cont.path.lastIndexOf('/') + 1);
	
	var labelFile = document.createElement("span");
	labelFile.className = "file";
	var file = new File([cont.binary], filename);
	files[a.href = URL.createObjectURL(file)] = file;
	a.download = labelFile.innerText = filename;
	
	a.append(labelDir);
	a.append(labelFile);
	viewFileList.append(a);
	
	var type = "";
	switch (filename.substring(filename.lastIndexOf(".") + 1).toLowerCase()) {
		case "png":
		case "bmp":
		case "gif":
		case "jpg":
		case "jpeg":
		case "exif":
		case "tiff":
			labelFile.className += " " + (type = "image");
			break;
		case "txt":
		case "xml":
		case "html":
		case "js":
		case "css":
		case "ts":
		case "java":
		case "cs":
		case "cpp":
		case "jsp":
		case "asp":
		case "php":
		case "bat":
		case "sh":
		case "smi":
		case "srt":
		case "ass":
			labelFile.className += " " + (type = "text");
			break;
	}
	
	if (type) {
		var labelPreview = document.createElement("span");
		labelPreview.className = "preview " + type;
		labelPreview.innerText = "[미리보기]";
		a.append(labelPreview);
	}
}
function showTargetImage(bmp) {
	ivTarget.innerHTML = "";
	if (bmp == null) {
		var comment = document.createElement("div");
		comment.id = "comment";
		comment.append("입력 이미지 없이 생성한");
		comment.append(document.createElement("br"));
		comment.append("이미지입니다.");
		ivTarget.append(comment);
		return;
	}
	ivTarget.append(bmp.update().canvas);
	var height = ivTarget.clientHeight;
	var ratio = height / bmp.height;
	var width = bmp.width * ratio;
	if (width > ivTarget.clientWidth) {
		width = ivTarget.clientWidth;
		ratio = width / bmp.width;
		height = bmp.height * ratio;
	}
	bmp.canvas.style.width = width + "px";
	bmp.canvas.style.height = height + "px";
	bmp.canvas.style.margin = (-height / 2) + "px " + (-width / 2) + "px";
}

function parse() {
	try {
		input.src = inputUrl.value;
	} catch (e) {
		console.debug(e);
	}
	return false;
}
async function paste(e) {
	var url = null;
	try {
		var clipboardItems = await navigator.clipboard.read();
		if (clipboardItems == null) {
			alert("모바일웹 등의 환경에서는\n클립보드 이미지를 가져올 수 없습니다");
			return;
		}
		for (var i = 0; i < clipboardItems.length; i++) {
			var item = clipboardItems[i];
			var blob = null;
			
			if (item.type) {
				if (item.type.startsWith('image/')) {
					blob = clipboardItem;
				} else if (item.type == 'text/plain') {
					url  = clipboardItem;
				}
			} else if (item.types) {
				for (var i = 0; i < item.types.length; i++) {
					if (item.types[i].startsWith("image/")) {
						blob = await item.getType(item.types[i]);
						break;
					} else if (item.types[i] == "text/plain") {
						url  = await item.getType(item.types[i]);
						break;
					}
				}
			}
			if (url) {
				url = await url.text();
			} else if (blob) {
				url = URL.createObjectURL(blob);
			}
			if (url) {
				e.preventDefault();
				inputUrl.value = input.src = url;
			}
		}
	} catch (ex) {
		console.debug(ex);
	} finally {
		if (url == null) {
			alert("클립보드에서 이미지를 불러오지 못했습니다.");
		}
	}
	return blob;
}

function onload() {
	inputUrl = document.getElementById("inputUrl");
	ivTarget = document.getElementById("ivTarget");
	viewFileList = document.getElementById("viewFileList");
	preview = document.getElementById("preview");
	
	// 포커스 상관없이 붙여넣기 이벤트 동작
	document.addEventListener("paste", paste);
	
	if (false) {
		// 모바일 환경용으로 만들려던 건데 모바일에서 안 됨........
		var comment = document.getElementById("comment");
		comment.append(document.createElement("br"));
		comment.append(document.createElement("br"));
		comment.append("클릭해서 복사한 이미지를");
		comment.append(document.createElement("br"));
		comment.append("붙여넣을 수 있습니다.");
		comment.style.margin = "-60px -100px";
		comment.style.cursor = "pointer";
		ivTarget.addEventListener("click", async (e) => {
			await paste(e);
		});
	}
	
	{	// 파일 열기
		var inputFile = document.createElement("input");
		inputFile.type = "file";
		inputFile.addEventListener("change", (e) => {
			if (inputFile.files.length) {
				inputUrl.value = input.src = URL.createObjectURL(inputFile.files[0]);
				inputFile.value = "";
			}
		});
		document.getElementById("btnOpenFile").addEventListener("click", async () => {
			inputFile.click();
		});
	}
	
	{	// 이미지 드래그해서 열기
		var cover = document.createElement("div");
		document.body.append(cover);
		cover.style.position = "fixed";
		cover.style.top = 0;
		cover.style.left = 0;
		cover.style.right = 0;
		cover.style.bottom = 0;
		cover.style.background = "rgba(127,127,127,0.1)";
		cover.style.display = "none";
		
		document.addEventListener("dragenter", (e) => {
			e.preventDefault();
			cover.style.display = "";
		});
		cover.addEventListener("dragleave", (e) => {
			e.preventDefault();
			cover.style.display = "none";
		});
		cover.addEventListener("dragover", (e) => {
			e.preventDefault();
		});
		cover.addEventListener("drop", async (e) => {
			e.preventDefault();
			cover.style.display = "none";
			if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length) {
				var file = e.dataTransfer.files[0];
				var ext = file.name.substring(file.name.length - 4);
				switch (ext.toLowerCase()) {
					case ".png":
					case ".bmp": {
						inputUrl.value = input.src = URL.createObjectURL(file);
					}
				}
			}
		});
		cover.addEventListener("click", (e) => {
			e.preventDefault();
			cover.style.display = "none";
		});
	}
	
	{	// 미리보기
		function addEL(els, en, selector, handler) {
			if (!Array.isArray(els)) {
				els = [els];
			}
			els.forEach((el) => {
				var wrapperHandler = null;
				if (handler) {
					wrapperHandler = (e) => {
						if (!e.target) return;
						var child = e.target.closest(selector);
						if (child) {
							handler.call(child, e);
						}
					};
				} else {
					handler = selector;
					wrapperHandler = (e) => {
						handler.call(el, e);
					}
				}
				en.replace(" ", ",").split(",").forEach((e) => {
					el.addEventListener(e.trim(), wrapperHandler);
				});
			});
		}
		var previewContent = document.getElementById("previewContent");
		addEL(viewFileList, "click", "span.preview", async (e) => {
			e.preventDefault();
			previewContent.innerHTML = "";
			var url = e.srcElement.parentElement.href;
			switch (e.srcElement.className.substring(8)) {
				case "text": {
					var file = files[url];
					var text = await file.text();
					previewContent.innerText = text;
					preview.style.display = "block";
					break;
				}
				case"image": {
					var img = new Image();
					img.src = url;
					previewContent.append(img);
					preview.style.display = "block";
				}
			}
		});
		document.getElementById("btnClosePreview").addEventListener("click", (e) => {
			preview.style.display = "";
		});
	}
}
</script>
<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
	white-space: nowrap;
}
html, body {
	width: 100%;
	height: 100%;
}
form {
	margin: 0 auto;
	width: 100%;
	max-width: 800px;
	height: 100%;
}
fieldset {
	height: 40px;
	background: #eee;
	border: 0;
	line-height: 30px;
	padding: 5px;
}
fieldset * {
	display: block;
	float: left;
	height: 30px;
	border: 0;
	line-height: 30px;
}
fieldset label {
	width: 40px;
}
fieldset input,
fieldset button {
	border: 1px solid #aaa;
}
fieldset input {
	width: calc(100% - 185px);
	padding: 0 5px;
	background: #fff;
	border-right: 0;
	border-radius: 10px 0 0 10px;
}
fieldset button {
	width: 60px;
	background: #ddd; 
	border-radius: 10px;
}
fieldset button[type=submit] {
	border-left: 0;
	border-radius: 0 10px 10px 0;
}
#btnOpenFile {
	margin-left: 5px;
	width: 80px;
}
#ivTarget {
	position: relative;
	background: #bbb;
	height: 200px;
}
#ivTarget > * {
	position: absolute;
	top: 50%;
	left: 50%;
}
#comment {
	width: 200px;;
	margin: -24px -100px;
	line-height: 24px;
	text-align: center;
}
#areaFileList {
	width: 100%;
	height: calc(100% - 240px);
	overflow: auto;
	background: #eee;
}
#viewFileList a {
	display: block;
	padding: 10px 10px 10px 2px;
	line-height: 20px;
	text-decoration: none;
	color: #000;
	background: linear-gradient(#fff, #eee);
	border-bottom: 1px solid #ccc;
}
#viewFileList a:hover {
	background: linear-gradient(#cef, #bde);
}
#viewFileList a > span {
	color: #aaa;
}
#viewFileList a > span.file {
	color: #038;
	text-decoration: underline;
	padding-left: 24px;
    background-repeat: no-repeat;
    background-position: 2px 2px;
    background-image: url("data:image/png;base64,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");
}
#viewFileList a > span.file.text {
	background-image: url("data:image/png;base64,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");
}
#viewFileList a > span.file.image {
	background-image: url("data:image/png;base64,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");
}
#viewFileList a > span.preview {
	float: right;
	color: #666;
}
#preview {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	background: rgba(127, 127, 127, 0.1);
	display: none;
}
#previewWindow {
	position: fixed;
	top: 10px;
	left: 10px;
	right: 10px;
	bottom: 10px;
	border: 1px solid #000;
	border-radius: 10px;
	background: #fff;
	padding: 10px;
}
#previewContent {
	width: 100%;
	height: 100%;
	overflow: auto;
	white-space: pre;
}
#btnClosePreview {
	position: fixed;
	top: 10px;
	right: 10px;
	width: 50px;
	height: 50px;
	border: 0;
	background: transparent;
	font-size: 40px;
	cursor: pointer;
}
</style>
</head>
<body onload="onload();">
<form onsubmit="return parse();">
	<fieldset>
		<label for="inputUrl">URL:</label>
		<input type="text" id="inputUrl" value="" />
		<button type="submit">열기</button>
		<button type="button" id="btnOpenFile">파일 열기</button>
	</fieldset>
	<div id="ivTarget">
		<div id="comment">이미지를 드래그하거나<br />Ctrl+V 하셔도 됩니다.</div>
	</div>
	<div id="areaFileList">
		<div id="viewFileList"></div>
	</div>
	<div id="preview">
		<div id="previewWindow">
			<div id="previewContent"></div>
			<button type="button" id="btnClosePreview">×</button>
		</div>
	</div>
</form>
</body>
</html>